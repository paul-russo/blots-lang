start = time_now()

// Helper functions for mathematical operations
fibonacci = n => if n <= 1 then n else fibonacci(n - 1) + fibonacci(n - 2)

factorial = n => if n <= 1 then 1 else n * factorial(n - 1)

isDivisibleByAny = (n, factors) =>
    if len(factors) == 0 then false
    else if n % factors[0] == 0 then true
    else isDivisibleByAny(n, tail(factors))

isPrime = n => 
    if n <= 1 then false
    else if n <= 3 then true
    else if n % 2 == 0 then false
    else !isDivisibleByAny(n, collect(each range(floor(sqrt(n)) - 2) + 3))

// Complex number operations using records
complexAdd = (a, b) => [a[0] + b[0], a[1] + b[1]]

complexMul = (a, b) => [
    a[0] * b[0] - a[1] * b[1],
    a[0] * b[1] + a[1] * b[0]
]

complexMag = z => z[0] * z[0] + z[1] * z[1]

mandelbrot = (x, y, maxIter, iter, z) =>
    if iter >= maxIter then iter
    else if complexMag(z) > 4 then iter
    else mandelbrot(
        x, y, maxIter, 
        iter + 1, 
        complexAdd(complexMul(z, z), [x, y])
    )

// Main computation that exercises different language features
benchmark = n => {
    primes: filter(isPrime, range(n)),
    fibs: collect(each range(15) with i => fibonacci(i)),
    factorials: collect(each range(7) with i => factorial(i)),
    reverse_test: reverse(range(n)),
    mandel_test: each [[-2, -1], [-1, 0], [0, 0], [0.25, 0]] with point =>
        mandelbrot(point[0], point[1], 50, 0, [0, 0]),
    sum_squares: sum(...collect(each range(n) with i => i * i)),
    trig_test: each range(n) with i => [sin(i), cos(i), tan(i)]
}

// Run benchmark
output = benchmark(20)

print("that took {} seconds", time_now() - start)
